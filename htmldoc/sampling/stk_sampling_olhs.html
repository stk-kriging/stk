<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of stk_sampling_olhs</title>
  <meta name="keywords" content="stk_sampling_olhs">
  <meta name="description" content="STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">sampling</a> &gt; stk_sampling_olhs.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sampling&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>stk_sampling_olhs
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [x, aux] = stk_sampling_olhs(n, d, box, permut, extended) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample

 CALL: X = stk_sampling_olhs(N)

    generates a random Orthogonal Latin Hypercube (OLH) sample X, using the
    construction of Ye (1998). The algorithm only works for sample sizes N
    of the form 2^(R+1)+1, with R &gt;= 1. Trying to generate an OLHS with a 
    value of N that is not of this form generates an error. The number of 
    factors is D = 2*R, and the OLHS is defined on [-1; 1]^D.

 CALL: X = stk_sampling_olhs(N, D)

    does exactly the same thing, provided that there exists an integer R
    such that N = 2^(R+1)+1 and D = 2*R (or D is empty).

 CALL: X = stk_sampling_olhs(N, D, BOX)

    generates an OLHS on BOX. Again, D can be empty since the number of
    factors can be deduced from N.

 CALL: X = stk_sampling_olhs(N, D, BOX, PERMUT)

    uses a given permutation PERMUT, instead of a random permutation, to 
    initialize the construction of Ye (1998). As a result, the generated
    OLHS is not random anymore. PERMUT must be a permutation of 1:2^R. If
    BOX is empty, then the default domain [-1, 1]^D is used.

 NOTE: orthogonality

    The samples generated by this functions are only orthogonal, stricty-
    speaking, if BOX is a symmetric domain (e.g., [-1, 1]^D). Otherwise,
    the generated samples shound be called &quot;uncorrelated&quot;.

 REFERENCE: 

    Kenny Q. Ye, &quot;Orthogonal Column Latin Hypercubes and Their 
    Application in Computer Experiments&quot;, Journal of the American 
    Statistical Association, 93(444), 1430-1439, 1998.
    http://dx.doi.org/10.1080/01621459.1998.10473803

 See also: <a href="stk_sampling_randomlhs.html" class="code" title="function x = stk_sampling_randomlhs(n, dim, box)">stk_sampling_randomlhs</a>, <a href="stk_sampling_maximinlhs.html" class="code" title="function x = stk_sampling_maximinlhs(n, d, box, niter)">stk_sampling_maximinlhs</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../octave-sombrero.png)">
</ul>
This function is called by:
<ul style="list-style-image:url(../octave-sombrero.png)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% CALL: X = stk_sampling_olhs(N)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%    generates a random Orthogonal Latin Hypercube (OLH) sample X, using the</span>
0006 <span class="comment">%    construction of Ye (1998). The algorithm only works for sample sizes N</span>
0007 <span class="comment">%    of the form 2^(R+1)+1, with R &gt;= 1. Trying to generate an OLHS with a</span>
0008 <span class="comment">%    value of N that is not of this form generates an error. The number of</span>
0009 <span class="comment">%    factors is D = 2*R, and the OLHS is defined on [-1; 1]^D.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% CALL: X = stk_sampling_olhs(N, D)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%    does exactly the same thing, provided that there exists an integer R</span>
0014 <span class="comment">%    such that N = 2^(R+1)+1 and D = 2*R (or D is empty).</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% CALL: X = stk_sampling_olhs(N, D, BOX)</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%    generates an OLHS on BOX. Again, D can be empty since the number of</span>
0019 <span class="comment">%    factors can be deduced from N.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% CALL: X = stk_sampling_olhs(N, D, BOX, PERMUT)</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%    uses a given permutation PERMUT, instead of a random permutation, to</span>
0024 <span class="comment">%    initialize the construction of Ye (1998). As a result, the generated</span>
0025 <span class="comment">%    OLHS is not random anymore. PERMUT must be a permutation of 1:2^R. If</span>
0026 <span class="comment">%    BOX is empty, then the default domain [-1, 1]^D is used.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% NOTE: orthogonality</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%    The samples generated by this functions are only orthogonal, stricty-</span>
0031 <span class="comment">%    speaking, if BOX is a symmetric domain (e.g., [-1, 1]^D). Otherwise,</span>
0032 <span class="comment">%    the generated samples shound be called &quot;uncorrelated&quot;.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% REFERENCE:</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%    Kenny Q. Ye, &quot;Orthogonal Column Latin Hypercubes and Their</span>
0037 <span class="comment">%    Application in Computer Experiments&quot;, Journal of the American</span>
0038 <span class="comment">%    Statistical Association, 93(444), 1430-1439, 1998.</span>
0039 <span class="comment">%    http://dx.doi.org/10.1080/01621459.1998.10473803</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% See also: stk_sampling_randomlhs, stk_sampling_maximinlhs</span>
0042 
0043 <span class="comment">% Copyright Notice</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%    Copyright (C) 2012, 2013 SUPELEC</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%    Author:  Julien Bect  &lt;julien.bect@supelec.fr&gt;</span>
0048 
0049 <span class="comment">% Copying Permission Statement</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%    This file is part of</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%            STK: a Small (Matlab/Octave) Toolbox for Kriging</span>
0054 <span class="comment">%               (http://sourceforge.net/projects/kriging)</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%    STK is free software: you can redistribute it and/or modify it under</span>
0057 <span class="comment">%    the terms of the GNU General Public License as published by the Free</span>
0058 <span class="comment">%    Software Foundation,  either version 3  of the License, or  (at your</span>
0059 <span class="comment">%    option) any later version.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%    STK is distributed  in the hope that it will  be useful, but WITHOUT</span>
0062 <span class="comment">%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY</span>
0063 <span class="comment">%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public</span>
0064 <span class="comment">%    License for more details.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%    You should  have received a copy  of the GNU  General Public License</span>
0067 <span class="comment">%    along with STK.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0068 
0069 <a name="_sub0" href="#_subfunctions" class="code">function [x, aux] = stk_sampling_olhs(n, d, box, permut, extended)</a>
0070 
0071 <span class="keyword">if</span> nargin &gt; 5,
0072    stk_error (<span class="string">'Too many input arguments.'</span>, <span class="string">'TooManyInputArgs'</span>);
0073 <span class="keyword">end</span>
0074 
0075 <span class="keyword">if</span> nargin &lt; 5, extended = false; <span class="keyword">end</span>
0076 
0077 <span class="comment">%%% PROCESS INPUT ARGUMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0078 
0079 <span class="comment">% recover the &quot;order&quot; r from the value of n</span>
0080 r = floor(log2(n - 1) - 1);
0081 n_ = 2^(r + 1) + 1;
0082 <span class="keyword">if</span> (r == 0) || (abs(n - n_) &gt; eps),
0083     errmsg = <span class="string">'n must be an integer of the form 2^(r+1) + 1 with r &gt; 0'</span>;
0084     stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0085 <span class="keyword">end</span>
0086 n = n_;
0087 
0088 <span class="keyword">if</span> ~extended
0089     <span class="comment">% check that d has the correct value for a &quot;full&quot; Ye98-OLHS</span>
0090     <span class="comment">% (other values of d can be reached by removing columns from a full OLHS)</span>
0091     <span class="keyword">if</span> (nargin &gt; 1) &amp;&amp; ~isempty(d),
0092         <span class="keyword">if</span> d ~= 2 * r,
0093             errmsg = <span class="string">'Incorrect value of d, please read the documentation...'</span>;
0094             stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0095         <span class="keyword">end</span>
0096     <span class="keyword">else</span>
0097         d = 2 * r;
0098     <span class="keyword">end</span>
0099 <span class="keyword">else</span>
0100     <span class="comment">% check that d has the correct value for a &quot;full&quot; Cioppa-Lucas(2007) NOLHS</span>
0101     <span class="comment">% (other values of d can be reached by removing columns from a full NOLHS)</span>
0102     <span class="keyword">if</span> (nargin &gt; 1) &amp;&amp; ~isempty(d),
0103         <span class="keyword">if</span> d ~= r + 1 + nchoosek(r, 2),
0104             errmsg = <span class="string">'Incorrect value of d, please read the documentation...'</span>;
0105             stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0106         <span class="keyword">end</span>
0107     <span class="keyword">else</span>
0108         d = r + 1 + nchoosek(r, 2);
0109     <span class="keyword">end</span>
0110 <span class="keyword">end</span>
0111 
0112 <span class="comment">% number of &quot;positive levels&quot;</span>
0113 q = 2^r; <span class="comment">% = (n - 1)/2</span>
0114 
0115 <span class="comment">% box</span>
0116 <span class="keyword">if</span> (nargin &lt; 3) || isempty(box),
0117     box = repmat([-1; 1], 1, d);
0118 <span class="keyword">else</span>
0119     stk_assert_box(box);
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">% permutation</span>
0123 <span class="keyword">if</span> (nargin &lt; 4) || isempty(permut),
0124     permut = randperm(q)';
0125 <span class="keyword">else</span>
0126     permut = permut(:);
0127     <span class="keyword">if</span> ~isequal(sort(permut), (1:q)'),
0128         errmsg = sprintf(<span class="string">'permut should be a permutation of 1:%d.'</span>, q);
0129         stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0130     <span class="keyword">end</span>
0131 <span class="keyword">end</span>
0132 
0133 <span class="comment">%%% CONSTRUCT AN &quot;ORTHOGONAL&quot; LHS FOLLOWING PROCESS INPUT ARGUMENTS %%%%%%%%%%%</span>
0134 
0135 <span class="comment">% Construct permutation matrices A1, A2, ..., Ar</span>
0136 A = cell(1, r);
0137 <span class="keyword">for</span> i = 1:r,
0138     Ai = 1;
0139     <span class="keyword">for</span> j = 1:i,
0140         Z  = zeros(size(Ai));
0141         Ai = [Z Ai; Ai Z]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0142     <span class="keyword">end</span>
0143     <span class="keyword">for</span> j = (i+1):r,
0144         Z  = zeros(size(Ai));
0145         Ai = [Ai Z; Z Ai]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0146     <span class="keyword">end</span>
0147     A{i} = Ai;
0148 <span class="keyword">end</span>
0149 
0150 <span class="comment">% Construct the matrix M</span>
0151 M = [permut zeros(q, 2*r-1)];
0152 <span class="keyword">for</span> j = 1:r, <span class="comment">% from column 2 to column r+1</span>
0153     M(:, j+1) = A{j} * permut;
0154 <span class="keyword">end</span>
0155 <span class="keyword">if</span> ~extended, <span class="comment">% OLHS / Ye (1998)</span>
0156     <span class="keyword">for</span> j = 1:(r-1), <span class="comment">% from column r+2 to column 2*r</span>
0157         M(:, j+r+1) = A{j} * A{r} * permut;
0158     <span class="keyword">end</span>
0159 <span class="keyword">else</span> <span class="comment">% NOLHS / Cioppa &amp; Lucas(2007)</span>
0160     col = r + 2;
0161     <span class="keyword">for</span> j = 1:(r-1),
0162         <span class="keyword">for</span> k = (j + 1):r,
0163             M(:, col) = A{j} * A{k} * permut;
0164             col = col + 1;
0165         <span class="keyword">end</span>
0166     <span class="keyword">end</span>
0167 <span class="keyword">end</span>    
0168     
0169 <span class="comment">% Construct the matrix S</span>
0170 S = ones(q, 2*r);
0171 <span class="keyword">for</span> j = 1:r, <span class="comment">% from column 2 to column r+1</span>
0172     aj = 1;
0173     <span class="keyword">for</span> l = r:(-1):1,
0174         <span class="keyword">if</span> l == r - j + 1,
0175             aj = [-aj; aj]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0176         <span class="keyword">else</span>
0177             aj = [aj; aj]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0178         <span class="keyword">end</span>
0179     <span class="keyword">end</span>
0180     S(:, j+1) = aj;
0181 <span class="keyword">end</span>
0182 <span class="keyword">if</span> ~extended, <span class="comment">% OLHS / Ye (1998)</span>
0183     <span class="keyword">for</span> j = 1:(r-1), <span class="comment">% from column r+2 to column 2*r</span>
0184         S(:, r+1+j) = S(:, 2) .* S(:, j+2);
0185     <span class="keyword">end</span>
0186 <span class="keyword">else</span> <span class="comment">% NOLHS / Cioppa &amp; Lucas(2007)</span>
0187     col = r + 2;
0188     <span class="keyword">for</span> j = 1:(r - 1),
0189         <span class="keyword">for</span> k = (j + 1):r,
0190             S(:, col) = S(:, j+1) .* S(:, k+1);
0191             col = col + 1;
0192         <span class="keyword">end</span>
0193     <span class="keyword">end</span>
0194 <span class="keyword">end</span>
0195 
0196 <span class="comment">% Construct the matrix T</span>
0197 T = M .* S;
0198 
0199 <span class="comment">% Construct the OLHS X (with integer levels -q, ..., 0, ... +q)</span>
0200 x_integer_levels = [T; zeros(1, d); -T];
0201 
0202 <span class="comment">%%% CONVERT TO THE REQUESTED BOX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0203 
0204 <span class="comment">% Convert to positive integer levels (1 ... n)</span>
0205 x = x_integer_levels + q + 1;
0206 
0207 <span class="comment">% Convert to [0; 1]-valued levels</span>
0208 x = (2*x - 1) / (2*n);
0209 
0210 <span class="comment">% And, finally, convert to box</span>
0211 x = stk_dataframe (stk_rescale(x, [], box));
0212 x.info = <span class="string">'Created by stk_sampling_olhs'</span>;
0213 
0214 <span class="comment">% Note: the results reported in Cioppa &amp; Lucas correspond to the scaling</span>
0215 <span class="comment">%   x = struct('a', stk_rescale(x, [min(x); max(x)], box));</span>
0216 
0217 <span class="comment">%%% OUTPUT SOME AUXILIARY DATA IF REQUESTED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0218 
0219 <span class="keyword">if</span> nargout &gt; 1,
0220     aux = struct(<span class="string">'M'</span>, M, <span class="string">'S'</span>, S, <span class="string">'X'</span>, x_integer_levels);
0221 <span class="keyword">end</span>
0222 
0223 <span class="keyword">end</span> <span class="comment">% function stk_sampling_olhs</span>
0224 
0225 
0226 <span class="comment">%%</span>
0227 <span class="comment">% Check error for incorrect number of input arguments</span>
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 <span class="comment">%%</span>
0240 <span class="comment">% Check that the output is a dataframe</span>
0241 <span class="comment">% (all stk_sampling_* functions should behave similarly in this respect)</span>
0242 
0243 
0244 
0245 <span class="comment">%%</span>
0246 <span class="comment">% Check output argument</span></pre></div>
<hr>

<address>
   HTML documentation for <strong>STK 2.0.0</strong>,
   generated by <strong>
   <a href="http://www.artefact.tk/software/matlab/m2html/" title="M2HTML website">M2HTML 1.5</a></strong>
</address>

</body>
</html>