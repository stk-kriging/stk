<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of stk_sampling_olhs</title>
  <meta name="keywords" content="stk_sampling_olhs">
  <meta name="description" content="STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">sampling</a> &gt; stk_sampling_olhs.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for sampling&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>stk_sampling_olhs
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [x, aux] = stk_sampling_olhs(n, d, box, permut, extended) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample

 CALL: X = stk_sampling_olhs(N)

    generates a random Orthogonal Latin Hypercube (OLH) sample X, using the
    construction of Ye (1998). The algorithm only works for sample sizes N
    of the form 2^(R+1)+1, with R &gt;= 1. Trying to generate an OLHS with a 
    value of N that is not of this form generates an error. The number of 
    factors is D = 2*R, and the OLHS is defined on [-1; 1]^D.

 CALL: X = stk_sampling_olhs(N, D)

    does exactly the same thing, provided that there exists an integer R
    such that N = 2^(R+1)+1 and D = 2*R (or D is empty).

 CALL: X = stk_sampling_olhs(N, D, BOX)

    generates an OLHS on BOX. Again, D can be empty since the number of
    factors can be deduced from N.

 CALL: X = stk_sampling_olhs(N, D, BOX, PERMUT)

    uses a given permutation PERMUT, instead of a random permutation, to 
    initialize the construction of Ye (1998). As a result, the generated
    OLHS is not random anymore. PERMUT must be a permutation of 1:2^R. If
    BOX is empty, then the default domain [-1, 1]^D is used.

 NOTE: orthogonality

    The samples generated by this functions are only orthogonal, stricty-
    speaking, if BOX is a symmetric domain (e.g., [-1, 1]^D). Otherwise,
    the generated samples shound be called &quot;uncorrelated&quot;.

 REFERENCE: 

    Kenny Q. Ye, &quot;Orthogonal Column Latin Hypercubes and Their 
    Application in Computer Experiments&quot;, Journal of the American 
    Statistical Association, 93(444), 1430-1439, 1998.
    http://dx.doi.org/10.1080/01621459.1998.10473803

 See also: <a href="stk_sampling_randomlhs.html" class="code" title="function x = stk_sampling_randomlhs(n, dim, box)">stk_sampling_randomlhs</a>, <a href="stk_sampling_maximinlhs.html" class="code" title="function x = stk_sampling_maximinlhs(n, d, box, niter)">stk_sampling_maximinlhs</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../octave-sombrero.png)">
</ul>
This function is called by:
<ul style="list-style-image:url(../octave-sombrero.png)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% STK_SAMPLING_OLHS generates a random Orthogonal Latin Hypercube (OLH) sample</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% CALL: X = stk_sampling_olhs(N)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%    generates a random Orthogonal Latin Hypercube (OLH) sample X, using the</span>
0006 <span class="comment">%    construction of Ye (1998). The algorithm only works for sample sizes N</span>
0007 <span class="comment">%    of the form 2^(R+1)+1, with R &gt;= 1. Trying to generate an OLHS with a</span>
0008 <span class="comment">%    value of N that is not of this form generates an error. The number of</span>
0009 <span class="comment">%    factors is D = 2*R, and the OLHS is defined on [-1; 1]^D.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% CALL: X = stk_sampling_olhs(N, D)</span>
0012 <span class="comment">%</span>
0013 <span class="comment">%    does exactly the same thing, provided that there exists an integer R</span>
0014 <span class="comment">%    such that N = 2^(R+1)+1 and D = 2*R (or D is empty).</span>
0015 <span class="comment">%</span>
0016 <span class="comment">% CALL: X = stk_sampling_olhs(N, D, BOX)</span>
0017 <span class="comment">%</span>
0018 <span class="comment">%    generates an OLHS on BOX. Again, D can be empty since the number of</span>
0019 <span class="comment">%    factors can be deduced from N.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% CALL: X = stk_sampling_olhs(N, D, BOX, PERMUT)</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%    uses a given permutation PERMUT, instead of a random permutation, to</span>
0024 <span class="comment">%    initialize the construction of Ye (1998). As a result, the generated</span>
0025 <span class="comment">%    OLHS is not random anymore. PERMUT must be a permutation of 1:2^R. If</span>
0026 <span class="comment">%    BOX is empty, then the default domain [-1, 1]^D is used.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% NOTE: orthogonality</span>
0029 <span class="comment">%</span>
0030 <span class="comment">%    The samples generated by this functions are only orthogonal, stricty-</span>
0031 <span class="comment">%    speaking, if BOX is a symmetric domain (e.g., [-1, 1]^D). Otherwise,</span>
0032 <span class="comment">%    the generated samples shound be called &quot;uncorrelated&quot;.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% REFERENCE:</span>
0035 <span class="comment">%</span>
0036 <span class="comment">%    Kenny Q. Ye, &quot;Orthogonal Column Latin Hypercubes and Their</span>
0037 <span class="comment">%    Application in Computer Experiments&quot;, Journal of the American</span>
0038 <span class="comment">%    Statistical Association, 93(444), 1430-1439, 1998.</span>
0039 <span class="comment">%    http://dx.doi.org/10.1080/01621459.1998.10473803</span>
0040 <span class="comment">%</span>
0041 <span class="comment">% See also: stk_sampling_randomlhs, stk_sampling_maximinlhs</span>
0042 
0043 <span class="comment">% Copyright Notice</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%    Copyright (C) 2012, 2013 SUPELEC</span>
0046 <span class="comment">%</span>
0047 <span class="comment">%    Author:  Julien Bect  &lt;julien.bect@supelec.fr&gt;</span>
0048 
0049 <span class="comment">% Copying Permission Statement</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%    This file is part of</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%            STK: a Small (Matlab/Octave) Toolbox for Kriging</span>
0054 <span class="comment">%               (http://sourceforge.net/projects/kriging)</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%    STK is free software: you can redistribute it and/or modify it under</span>
0057 <span class="comment">%    the terms of the GNU General Public License as published by the Free</span>
0058 <span class="comment">%    Software Foundation,  either version 3  of the License, or  (at your</span>
0059 <span class="comment">%    option) any later version.</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%    STK is distributed  in the hope that it will  be useful, but WITHOUT</span>
0062 <span class="comment">%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY</span>
0063 <span class="comment">%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public</span>
0064 <span class="comment">%    License for more details.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">%    You should  have received a copy  of the GNU  General Public License</span>
0067 <span class="comment">%    along with STK.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0068 
0069 <a name="_sub0" href="#_subfunctions" class="code">function [x, aux] = stk_sampling_olhs(n, d, box, permut, extended)</a>
0070 <span class="keyword">if</span> nargin &gt; 5,
0071    stk_error (<span class="string">'Too many input arguments.'</span>, <span class="string">'TooManyInputArgs'</span>);
0072 <span class="keyword">end</span>
0073 
0074 <span class="keyword">if</span> nargin &lt; 5, extended = false; <span class="keyword">end</span>
0075 
0076 <span class="comment">%%% PROCESS INPUT ARGUMENTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0077 
0078 <span class="comment">% recover the &quot;order&quot; r from the value of n</span>
0079 r = floor(log2(n - 1) - 1);
0080 n_ = 2^(r + 1) + 1;
0081 <span class="keyword">if</span> (r == 0) || (abs(n - n_) &gt; eps),
0082     errmsg = <span class="string">'n must be an integer of the form 2^(r+1) + 1 with r &gt; 0'</span>;
0083     stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0084 <span class="keyword">end</span>
0085 n = n_;
0086 
0087 <span class="keyword">if</span> ~extended
0088     <span class="comment">% check that d has the correct value for a &quot;full&quot; Ye98-OLHS</span>
0089     <span class="comment">% (other values of d can be reached by removing columns from a full OLHS)</span>
0090     <span class="keyword">if</span> (nargin &gt; 1) &amp;&amp; ~isempty(d),
0091         <span class="keyword">if</span> d ~= 2 * r,
0092             errmsg = <span class="string">'Incorrect value of d, please read the documentation...'</span>;
0093             stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0094         <span class="keyword">end</span>
0095     <span class="keyword">else</span>
0096         d = 2 * r;
0097     <span class="keyword">end</span>
0098 <span class="keyword">else</span>
0099     <span class="comment">% check that d has the correct value for a &quot;full&quot; Cioppa-Lucas(2007) NOLHS</span>
0100     <span class="comment">% (other values of d can be reached by removing columns from a full NOLHS)</span>
0101     <span class="keyword">if</span> (nargin &gt; 1) &amp;&amp; ~isempty(d),
0102         <span class="keyword">if</span> d ~= r + 1 + nchoosek(r, 2),
0103             errmsg = <span class="string">'Incorrect value of d, please read the documentation...'</span>;
0104             stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0105         <span class="keyword">end</span>
0106     <span class="keyword">else</span>
0107         d = r + 1 + nchoosek(r, 2);
0108     <span class="keyword">end</span>
0109 <span class="keyword">end</span>
0110 
0111 <span class="comment">% number of &quot;positive levels&quot;</span>
0112 q = 2^r; <span class="comment">% = (n - 1)/2</span>
0113 
0114 <span class="comment">% box</span>
0115 <span class="keyword">if</span> (nargin &lt; 3) || isempty(box),
0116     box = repmat([-1; 1], 1, d);
0117 <span class="keyword">else</span>
0118     stk_assert_box(box);
0119 <span class="keyword">end</span>
0120 
0121 <span class="comment">% permutation</span>
0122 <span class="keyword">if</span> (nargin &lt; 4) || isempty(permut),
0123     permut = randperm(q)';
0124 <span class="keyword">else</span>
0125     permut = permut(:);
0126     <span class="keyword">if</span> ~isequal(sort(permut), (1:q)'),
0127         errmsg = sprintf(<span class="string">'permut should be a permutation of 1:%d.'</span>, q);
0128         stk_error(errmsg, <span class="string">'IncorrectArgument'</span>);
0129     <span class="keyword">end</span>
0130 <span class="keyword">end</span>
0131 
0132 <span class="comment">%%% CONSTRUCT AN &quot;ORTHOGONAL&quot; LHS FOLLOWING PROCESS INPUT ARGUMENTS %%%%%%%%%%%</span>
0133 
0134 <span class="comment">% Construct permutation matrices A1, A2, ..., Ar</span>
0135 A = cell(1, r);
0136 <span class="keyword">for</span> i = 1:r,
0137     Ai = 1;
0138     <span class="keyword">for</span> j = 1:i,
0139         Z  = zeros(size(Ai));
0140         Ai = [Z Ai; Ai Z]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0141     <span class="keyword">end</span>
0142     <span class="keyword">for</span> j = (i+1):r,
0143         Z  = zeros(size(Ai));
0144         Ai = [Ai Z; Z Ai]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0145     <span class="keyword">end</span>
0146     A{i} = Ai;
0147 <span class="keyword">end</span>
0148 
0149 <span class="comment">% Construct the matrix M</span>
0150 M = [permut zeros(q, 2*r-1)];
0151 <span class="keyword">for</span> j = 1:r, <span class="comment">% from column 2 to column r+1</span>
0152     M(:, j+1) = A{j} * permut;
0153 <span class="keyword">end</span>
0154 <span class="keyword">if</span> ~extended, <span class="comment">% OLHS / Ye (1998)</span>
0155     <span class="keyword">for</span> j = 1:(r-1), <span class="comment">% from column r+2 to column 2*r</span>
0156         M(:, j+r+1) = A{j} * A{r} * permut;
0157     <span class="keyword">end</span>
0158 <span class="keyword">else</span> <span class="comment">% NOLHS / Cioppa &amp; Lucas(2007)</span>
0159     col = r + 2;
0160     <span class="keyword">for</span> j = 1:(r-1),
0161         <span class="keyword">for</span> k = (j + 1):r,
0162             M(:, col) = A{j} * A{k} * permut;
0163             col = col + 1;
0164         <span class="keyword">end</span>
0165     <span class="keyword">end</span>
0166 <span class="keyword">end</span>    
0167     
0168 <span class="comment">% Construct the matrix S</span>
0169 S = ones(q, 2*r);
0170 <span class="keyword">for</span> j = 1:r, <span class="comment">% from column 2 to column r+1</span>
0171     aj = 1;
0172     <span class="keyword">for</span> l = r:(-1):1,
0173         <span class="keyword">if</span> l == r - j + 1,
0174             aj = [-aj; aj]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0175         <span class="keyword">else</span>
0176             aj = [aj; aj]; <span class="comment">%#ok&lt;AGROW&gt;</span>
0177         <span class="keyword">end</span>
0178     <span class="keyword">end</span>
0179     S(:, j+1) = aj;
0180 <span class="keyword">end</span>
0181 <span class="keyword">if</span> ~extended, <span class="comment">% OLHS / Ye (1998)</span>
0182     <span class="keyword">for</span> j = 1:(r-1), <span class="comment">% from column r+2 to column 2*r</span>
0183         S(:, r+1+j) = S(:, 2) .* S(:, j+2);
0184     <span class="keyword">end</span>
0185 <span class="keyword">else</span> <span class="comment">% NOLHS / Cioppa &amp; Lucas(2007)</span>
0186     col = r + 2;
0187     <span class="keyword">for</span> j = 1:(r - 1),
0188         <span class="keyword">for</span> k = (j + 1):r,
0189             S(:, col) = S(:, j+1) .* S(:, k+1);
0190             col = col + 1;
0191         <span class="keyword">end</span>
0192     <span class="keyword">end</span>
0193 <span class="keyword">end</span>
0194 
0195 <span class="comment">% Construct the matrix T</span>
0196 T = M .* S;
0197 
0198 <span class="comment">% Construct the OLHS X (with integer levels -q, ..., 0, ... +q)</span>
0199 x_integer_levels = [T; zeros(1, d); -T];
0200 
0201 <span class="comment">%%% CONVERT TO THE REQUESTED BOX %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0202 
0203 <span class="comment">% Convert to positive integer levels (1 ... n)</span>
0204 x = x_integer_levels + q + 1;
0205 
0206 <span class="comment">% Convert to [0; 1]-valued levels</span>
0207 x = (2*x - 1) / (2*n);
0208 
0209 <span class="comment">% And, finally, convert to box</span>
0210 x = stk_dataframe(stk_rescale(x, [], box));
0211 
0212 <span class="comment">% Note: the results reported in Cioppa &amp; Lucas correspond to the scaling</span>
0213 <span class="comment">%   x = struct('a', stk_rescale(x, [min(x); max(x)], box));</span>
0214 
0215 <span class="comment">%%% OUTPUT SOME AUXILIARY DATA IF REQUESTED %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0216 
0217 <span class="keyword">if</span> nargout &gt; 1,
0218     aux = struct(<span class="string">'M'</span>, M, <span class="string">'S'</span>, S, <span class="string">'X'</span>, x_integer_levels);
0219 <span class="keyword">end</span>
0220 
0221 <span class="keyword">end</span> <span class="comment">% function stk_sampling_olhs</span>
0222 
0223 
0224 
0225 <span class="comment">%%%%%%%%%%%%%</span>
0226 <span class="comment">%%% tests %%%</span>
0227 <span class="comment">%%%%%%%%%%%%%</span>
0228 
0229 <span class="comment">%%</span>
0230 <span class="comment">% Check error for incorrect number of input arguments</span>
0231 
0232 <span class="comment">%!shared x, n, d, box, permut</span>
0233 <span class="comment">%! n = 5; d = 2; box = [0 0; 1, 1]; permut = 1:2;</span>
0234 
0235 <span class="comment">%!error x = stk_sampling_olhs();</span>
0236 <span class="comment">%!test  x = stk_sampling_olhs(n);</span>
0237 <span class="comment">%!test  x = stk_sampling_olhs(n, d);</span>
0238 <span class="comment">%!test  x = stk_sampling_olhs(n, d, box);</span>
0239 <span class="comment">%!test  x = stk_sampling_olhs(n, d, box, permut);</span>
0240 <span class="comment">%!error x = stk_sampling_olhs(n, d, box, permut, pi);</span>
0241 
0242 <span class="comment">%%</span>
0243 <span class="comment">% Check that the output is a dataframe</span>
0244 <span class="comment">% (all stk_sampling_* functions should behave similarly in this respect)</span>
0245 
0246 <span class="comment">%!assert (isa(x, 'stk_dataframe'));</span>
0247 
0248 <span class="comment">%%</span>
0249 <span class="comment">% Check output argument</span>
0250 
0251 <span class="comment">%!test</span>
0252 <span class="comment">%! for r = 1:5</span>
0253 <span class="comment">%!</span>
0254 <span class="comment">%!   n = 2^(r+1) + 1; d = 2*r;</span>
0255 <span class="comment">%!   x = stk_sampling_olhs(n, d);</span>
0256 <span class="comment">%!</span>
0257 <span class="comment">%!   assert(isequal(size(x), [n d]));</span>
0258 <span class="comment">%!</span>
0259 <span class="comment">%!   box = repmat([-1; 1], 1, d);</span>
0260 <span class="comment">%!   assert(stk_is_lhs(x, n, d, box));</span>
0261 <span class="comment">%!</span>
0262 <span class="comment">%!   w = double(x)' * double(x);</span>
0263 <span class="comment">%!   assert(stk_isequal_tolabs(w/w(1,1), eye(d)));</span>
0264 <span class="comment">%!</span>
0265 <span class="comment">%! end</span></pre></div>
<hr>

<address>
   HTML documentation for <strong>STK 2.0.0</strong>,
   generated by <strong>
   <a href="http://www.artefact.tk/software/matlab/m2html/" title="M2HTML website">M2HTML 1.5</a></strong>
</address>

</body>
</html>