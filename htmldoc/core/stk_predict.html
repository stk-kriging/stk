<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of stk_predict</title>
  <meta name="keywords" content="stk_predict">
  <meta name="description" content="STK_PREDICT performs a kriging prediction from data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">core</a> &gt; stk_predict.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for core&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>stk_predict
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STK_PREDICT performs a kriging prediction from data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> STK_PREDICT performs a kriging prediction from data

 CALL: ZP = stk_predict(MODEL, XI, ZI, XP)

    performs a kriging prediction at the points XP, given the observations
    (XI, ZI) and the prior MODEL. The input arguments XI, ZI, and XP can be
    either numerical matrices or dataframes. More precisely, on a factor space
    of dimension DIM,

     * XI must have size NI x DIM,
     * ZI must have size NI x 1,
     * XP must have size NP x DIM,

    where NI is the number of observations and NP the number of prediction
    points. The output ZP is a dataframe of size NP x 2, with:

     * the kriging predictor in the first column (ZP.mean), and
     * the kriging variance in the second column (ZP.var).

 CALL: [ZP, LAMBDA, MU] = stk_predict(MODEL, XI, ZI, XP)

    also returns the matrix of kriging weights LAMBDA and the matrix of
    Lagrange multipliers MU.

 CALL: [ZP, LAMBDA, MU, K] = stk_predict(MODEL, XI, ZI, XP)

    also returns the posterior covariance matrix K at the locations XP (this is
    an NP x NP covariance matrix). From a frequentist point of view, K can be
    seen as the covariance matrix of the prediction errors.

 SPECIAL CASE

    If ZI is empty, everything but ZP.mean is computed. Indeed, neither the
    kriging variance ZP.var nor the matrices LAMBDA and MU actually depend on
    the observed values.

 EXAMPLE: see examples/example01.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../octave-sombrero.png)">
<li><a href="stk_predict.html" class="code" title="function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt)">stk_predict</a>	STK_PREDICT performs a kriging prediction from data</li></ul>
This function is called by:
<ul style="list-style-image:url(../octave-sombrero.png)">
<li><a href="stk_predict.html" class="code" title="function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt)">stk_predict</a>	STK_PREDICT performs a kriging prediction from data</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% STK_PREDICT performs a kriging prediction from data</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% CALL: ZP = stk_predict(MODEL, XI, ZI, XP)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%    performs a kriging prediction at the points XP, given the observations</span>
0006 <span class="comment">%    (XI, ZI) and the prior MODEL. The input arguments XI, ZI, and XP can be</span>
0007 <span class="comment">%    either numerical matrices or dataframes. More precisely, on a factor space</span>
0008 <span class="comment">%    of dimension DIM,</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%     * XI must have size NI x DIM,</span>
0011 <span class="comment">%     * ZI must have size NI x 1,</span>
0012 <span class="comment">%     * XP must have size NP x DIM,</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%    where NI is the number of observations and NP the number of prediction</span>
0015 <span class="comment">%    points. The output ZP is a dataframe of size NP x 2, with:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%     * the kriging predictor in the first column (ZP.mean), and</span>
0018 <span class="comment">%     * the kriging variance in the second column (ZP.var).</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% CALL: [ZP, LAMBDA, MU] = stk_predict(MODEL, XI, ZI, XP)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%    also returns the matrix of kriging weights LAMBDA and the matrix of</span>
0023 <span class="comment">%    Lagrange multipliers MU.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% CALL: [ZP, LAMBDA, MU, K] = stk_predict(MODEL, XI, ZI, XP)</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%    also returns the posterior covariance matrix K at the locations XP (this is</span>
0028 <span class="comment">%    an NP x NP covariance matrix). From a frequentist point of view, K can be</span>
0029 <span class="comment">%    seen as the covariance matrix of the prediction errors.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% SPECIAL CASE</span>
0032 <span class="comment">%</span>
0033 <span class="comment">%    If ZI is empty, everything but ZP.mean is computed. Indeed, neither the</span>
0034 <span class="comment">%    kriging variance ZP.var nor the matrices LAMBDA and MU actually depend on</span>
0035 <span class="comment">%    the observed values.</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% EXAMPLE: see examples/example01.m</span>
0038 
0039 <span class="comment">% Copyright Notice</span>
0040 <span class="comment">%</span>
0041 <span class="comment">%    Copyright (C) 2011-2013 SUPELEC</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%    Authors:   Julien Bect       &lt;julien.bect@supelec.fr&gt;</span>
0044 <span class="comment">%               Emmanuel Vazquez  &lt;emmanuel.vazquez@supelec.fr&gt;</span>
0045 
0046 <span class="comment">% Copying Permission Statement</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%    This file is part of</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%            STK: a Small (Matlab/Octave) Toolbox for Kriging</span>
0051 <span class="comment">%               (http://sourceforge.net/projects/kriging)</span>
0052 <span class="comment">%</span>
0053 <span class="comment">%    STK is free software: you can redistribute it and/or modify it under</span>
0054 <span class="comment">%    the terms of the GNU General Public License as published by the Free</span>
0055 <span class="comment">%    Software Foundation,  either version 3  of the License, or  (at your</span>
0056 <span class="comment">%    option) any later version.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%    STK is distributed  in the hope that it will  be useful, but WITHOUT</span>
0059 <span class="comment">%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY</span>
0060 <span class="comment">%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public</span>
0061 <span class="comment">%    License for more details.</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%    You should  have received a copy  of the GNU  General Public License</span>
0064 <span class="comment">%    along with STK.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0065 
0066 <a name="_sub0" href="#_subfunctions" class="code">function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt)</a>
0067 
0068 <span class="keyword">if</span> nargin &gt; 4,
0069    stk_error (<span class="string">'Too many input arguments.'</span>, <span class="string">'TooManyInputArgs'</span>);
0070 <span class="keyword">end</span>
0071 
0072 <span class="comment">%=== todo: these should become options</span>
0073 
0074 display_waitbar = false;
0075 block_size = [];
0076 options = {display_waitbar, block_size};
0077 
0078 <span class="comment">%=== prepare lefthand side of the kriging equation</span>
0079 
0080 kreq = stk_kriging_equation(model, xi);
0081 
0082 <span class="comment">%=== solve the kriging system and extract all requested outputs</span>
0083 
0084 <span class="keyword">if</span> nargout == 1,
0085     
0086     <span class="comment">% note: calling @stk_kriging_equation.stk_predict without its second output</span>
0087     <span class="comment">% argument is more memory-efficient (we don't build full lambda_mu and RS</span>
0088     <span class="comment">% matrices)</span>
0089     
0090     zp = <a href="stk_predict.html" class="code" title="function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt)">stk_predict</a>(kreq, zi, xt, options{:});
0091     
0092 <span class="keyword">else</span>
0093     
0094     [zp, kreq] = <a href="stk_predict.html" class="code" title="function [zp, lambda, mu, K] = stk_predict(model, xi, zi, xt)">stk_predict</a>(kreq, zi, xt, options{:});
0095     
0096     <span class="comment">% extracts kriging weights (if requested)</span>
0097     <span class="keyword">if</span> nargout &gt; 1,
0098         lambda = kreq.lambda;
0099     <span class="keyword">end</span>
0100     
0101     <span class="comment">% extracts Lagrange multipliers (if requested)</span>
0102     <span class="keyword">if</span> nargout &gt; 2,
0103         mu = kreq.mu;
0104     <span class="keyword">end</span>
0105     
0106     <span class="comment">% compute posterior covariance matrix (if requested)</span>
0107     <span class="keyword">if</span> nargout &gt; 3,
0108         nt = size(xt, 1);
0109         K = stk_posterior_matcov(kreq, 1:nt, 1:nt, false);
0110     <span class="keyword">end</span>
0111     
0112 <span class="keyword">end</span>
0113 
0114 <span class="keyword">end</span>
0115 
0116 
0117 <span class="comment">%%%%%%%%%%%%%</span>
0118 <span class="comment">%%% tests %%%</span>
0119 <span class="comment">%%%%%%%%%%%%%</span>
0120 
0121 <span class="comment">%!shared n, m, model, x0, x_obs, z_obs, x_prd, y_prd1, idx_obs, idx_prd</span>
0122 <span class="comment">%!</span>
0123 <span class="comment">%! n = 10;     % number of observations</span>
0124 <span class="comment">%! m = n + 1;  % number of predictions</span>
0125 <span class="comment">%! d = 1;      % dimension of the input space</span>
0126 <span class="comment">%!</span>
0127 <span class="comment">%! x0 = stk_sampling_regulargrid(n+m, d, [0; pi]);</span>
0128 <span class="comment">%!</span>
0129 <span class="comment">%! idx_obs = (2:2:(n+m-1))';</span>
0130 <span class="comment">%! idx_prd = (1:2:(n+m))';</span>
0131 <span class="comment">%!</span>
0132 <span class="comment">%! x_obs = x0(idx_obs);</span>
0133 <span class="comment">%! z_obs = sin (double (x_obs));</span>
0134 <span class="comment">%! x_prd = x0(idx_prd);</span>
0135 <span class="comment">%!</span>
0136 <span class="comment">%! model = stk_model('stk_materncov32_iso');</span>
0137 <span class="comment">%! model.order = 0; % this is currently the default, but better safe than sorry</span>
0138 
0139 <span class="comment">%!error y_prd1 = stk_predict();</span>
0140 <span class="comment">%!error y_prd1 = stk_predict(model);</span>
0141 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs);</span>
0142 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs, z_obs);</span>
0143 <span class="comment">%!test  y_prd1 = stk_predict(model, x_obs, z_obs, x_prd);</span>
0144 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs, z_obs, x_prd, 0);</span>
0145 
0146 <span class="comment">%!test</span>
0147 <span class="comment">%! [y_prd1, lambda, mu, K] = stk_predict(model, x_obs, z_obs, x_prd);</span>
0148 <span class="comment">%! assert(isequal(size(lambda), [n m]));</span>
0149 <span class="comment">%! assert(isequal(size(mu), [1 m]));  % ordinary kriging</span>
0150 <span class="comment">%! assert(isequal(size(K), [m m]));</span>
0151 
0152 <span class="comment">%!test % use old-style .a structures (legacy)</span>
0153 <span class="comment">%! y_prd2 = stk_predict(model, struct('a', double(x_obs)), ...</span>
0154 <span class="comment">%!                      struct('a', double(z_obs)), struct('a', double(x_prd)));</span>
0155 <span class="comment">%! assert(stk_isequal_tolrel(double(y_prd1), double(y_prd2)));</span></pre></div>
<hr>

<address>
   HTML documentation for <strong>STK 2.0.0</strong>,
   generated by <strong>
   <a href="http://www.artefact.tk/software/matlab/m2html/" title="M2HTML website">M2HTML 1.5</a></strong>
</address>

</body>
</html>