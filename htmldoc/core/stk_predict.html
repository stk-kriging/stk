<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of stk_predict</title>
  <meta name="keywords" content="stk_predict">
  <meta name="description" content="STK_PREDICT performs a kriging prediction from data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">core</a> &gt; stk_predict.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for core&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>stk_predict
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>STK_PREDICT performs a kriging prediction from data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [zp, lambda, mu] = stk_predict(model, xi, zi, xt) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> STK_PREDICT performs a kriging prediction from data 

 CALL: ZP = stk_predict(MODEL, XI, ZI, XP)

    computes the kriging predictor ZP at the points XP, given the observations
    (XI, ZI) and the prior MODEL. In general (see special cases below), XI, ZI,
    XP and ZP are structures whose field 'a' contains the actual numerical
    data. More precisely, on a DIM-dimensional factor space,

     * XI.a must be a NI x DIM matrix, where NI is the number of observations,
     * ZI.a must be a column vector of length NI,
     * XP.a must be a NP x DIM matrix, where NP is the number of prediction
       points,
     * ZP.a is a column vector of length NP.

    Additionally to the predicted values ZP.a, stk_predict() returns the
    kriging variances ZP.v at the same points. ZP.v is a column vector of
    length NP.

 CALL: [ZP, LAMBDA, MU] = stk_predict(MODEL, XI, ZI, XP)

    also returns the matrix of kriging weights LAMBDA and the matrix of
    Lagrange multipliers MU.

 SPECIAL CASE #1

    If MODEL has a field 'Kx_cache', XI and XP are expected to be vectors of
    integer indices (instead of structures with an 'a' field). This feature is
    not fully documented as of today... If XT is empty, it is assumed that
    predictions must be computed at all points of the underlying discrete
    space.

 SPECIAL CASE #2

    If ZI is empty, everything but ZP.a is computed. Indeed, neither the
    kriging variance ZP.v nor the matrices LAMBDA and MU actually depend on the
    observed values.
 
 EXAMPLE: see examples/example01.m</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="stk_make_matcov.html" class="code" title="function [K, P] = stk_make_matcov(model, x0, x1)">stk_make_matcov</a>	STK_MAKE_MATCOV computes a covariance matrix (and a design matrix).</li><li><a href="../misc/config/stk_is_octave_in_use.html" class="code" title="function octave_in_use = stk_is_octave_in_use()">stk_is_octave_in_use</a>	STK_IS_OCTAVE_IN_USE returns true if the STK runs in Octave</li><li><a href="../misc/error/stk_narginchk.html" class="code" title="function [err_msg, err_mnemonic] = stk_narginchk(n_low, n_high)">stk_narginchk</a>	STK_NARGINCHK checks whether the number of input arguments is acceptable.</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="../examples/example01.html" class="code" title="">example01</a>	Example 01 constructs a kriging approximation in 1D</li><li><a href="../examples/example02.html" class="code" title="">example02</a>	Example 02 constructs a kriging approximation in 1D</li><li><a href="../examples/example03.html" class="code" title="">example03</a>	Example 03 constructs a kriging approximation in 2D</li><li><a href="../examples/example05.html" class="code" title="">example05</a>	Example 05 generates conditioned sample paths</li><li><a href="../examples/example06.html" class="code" title="">example06</a>	Example 06 compares several kriging approximations in 1D</li><li><a href="../examples/example08.html" class="code" title="">example08</a>	Example 08 constructs a kriging approximation in 1D from noisy</li></ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% STK_PREDICT performs a kriging prediction from data</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% CALL: ZP = stk_predict(MODEL, XI, ZI, XP)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">%    computes the kriging predictor ZP at the points XP, given the observations</span>
0006 <span class="comment">%    (XI, ZI) and the prior MODEL. In general (see special cases below), XI, ZI,</span>
0007 <span class="comment">%    XP and ZP are structures whose field 'a' contains the actual numerical</span>
0008 <span class="comment">%    data. More precisely, on a DIM-dimensional factor space,</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%     * XI.a must be a NI x DIM matrix, where NI is the number of observations,</span>
0011 <span class="comment">%     * ZI.a must be a column vector of length NI,</span>
0012 <span class="comment">%     * XP.a must be a NP x DIM matrix, where NP is the number of prediction</span>
0013 <span class="comment">%       points,</span>
0014 <span class="comment">%     * ZP.a is a column vector of length NP.</span>
0015 <span class="comment">%</span>
0016 <span class="comment">%    Additionally to the predicted values ZP.a, stk_predict() returns the</span>
0017 <span class="comment">%    kriging variances ZP.v at the same points. ZP.v is a column vector of</span>
0018 <span class="comment">%    length NP.</span>
0019 <span class="comment">%</span>
0020 <span class="comment">% CALL: [ZP, LAMBDA, MU] = stk_predict(MODEL, XI, ZI, XP)</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%    also returns the matrix of kriging weights LAMBDA and the matrix of</span>
0023 <span class="comment">%    Lagrange multipliers MU.</span>
0024 <span class="comment">%</span>
0025 <span class="comment">% SPECIAL CASE #1</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%    If MODEL has a field 'Kx_cache', XI and XP are expected to be vectors of</span>
0028 <span class="comment">%    integer indices (instead of structures with an 'a' field). This feature is</span>
0029 <span class="comment">%    not fully documented as of today... If XT is empty, it is assumed that</span>
0030 <span class="comment">%    predictions must be computed at all points of the underlying discrete</span>
0031 <span class="comment">%    space.</span>
0032 <span class="comment">%</span>
0033 <span class="comment">% SPECIAL CASE #2</span>
0034 <span class="comment">%</span>
0035 <span class="comment">%    If ZI is empty, everything but ZP.a is computed. Indeed, neither the</span>
0036 <span class="comment">%    kriging variance ZP.v nor the matrices LAMBDA and MU actually depend on the</span>
0037 <span class="comment">%    observed values.</span>
0038 <span class="comment">%</span>
0039 <span class="comment">% EXAMPLE: see examples/example01.m</span>
0040 
0041 <span class="comment">% Copyright Notice</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%    Copyright (C) 2011, 2012 SUPELEC</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%    Authors:   Julien Bect       &lt;julien.bect@supelec.fr&gt;</span>
0046 <span class="comment">%               Emmanuel Vazquez  &lt;emmanuel.vazquez@supelec.fr&gt;</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Copying Permission Statement</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%    This file is part of</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%            STK: a Small (Matlab/Octave) Toolbox for Kriging</span>
0053 <span class="comment">%               (http://sourceforge.net/projects/kriging)</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%    STK is free software: you can redistribute it and/or modify it under</span>
0056 <span class="comment">%    the terms of the GNU General Public License as published by the Free</span>
0057 <span class="comment">%    Software Foundation,  either version 3  of the License, or  (at your</span>
0058 <span class="comment">%    option) any later version.</span>
0059 <span class="comment">%</span>
0060 <span class="comment">%    STK is distributed  in the hope that it will  be useful, but WITHOUT</span>
0061 <span class="comment">%    ANY WARRANTY;  without even the implied  warranty of MERCHANTABILITY</span>
0062 <span class="comment">%    or FITNESS  FOR A  PARTICULAR PURPOSE.  See  the GNU  General Public</span>
0063 <span class="comment">%    License for more details.</span>
0064 <span class="comment">%</span>
0065 <span class="comment">%    You should  have received a copy  of the GNU  General Public License</span>
0066 <span class="comment">%    along with STK.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
0067 
0068 <a name="_sub0" href="#_subfunctions" class="code">function [zp, lambda, mu] = stk_predict(model, xi, zi, xt)</a>
0069 
0070 <a href="../misc/error/stk_narginchk.html" class="code" title="function [err_msg, err_mnemonic] = stk_narginchk(n_low, n_high)">stk_narginchk</a>(4, 4);
0071 
0072 <span class="comment">%=== use indices or matrices for xi &amp; xt ?</span>
0073 
0074 use_indices = isfield(model,<span class="string">'Kx_cache'</span>);
0075 
0076 <span class="keyword">if</span> use_indices,
0077     xi = xi(:);
0078     ni = size(xi, 1); <span class="comment">% number of observations</span>
0079     <span class="keyword">if</span> isempty(xt), xt = 1:size(model.Kx_cache,1); <span class="keyword">end</span>
0080     nt = length(xt);
0081 <span class="keyword">else</span>
0082     ni = size(xi.a, 1); <span class="comment">% number of observations</span>
0083     assert( ~isempty(xt.a) );
0084     nt = size(xt.a,1);
0085 <span class="keyword">end</span>
0086 
0087 assert( isempty(zi) || (size(zi.a,1)==ni) );
0088 <span class="comment">%=== handle other optional arguments</span>
0089 
0090 <span class="comment">% parser = inputParser; % parse optional arguments</span>
0091 <span class="comment">% parser.addOptional( 'BlockSize', [] );</span>
0092 <span class="comment">% parser.addOptional( 'DisplayWaitBar', false );</span>
0093 <span class="comment">% parser.parse( varargin{:} );</span>
0094 <span class="comment">%</span>
0095 <span class="comment">% display_waitbar = parser.Results.DisplayWaitBar;</span>
0096 <span class="comment">% if display_waitbar,</span>
0097 <span class="comment">%     hwb = waitbar(0,'In stk\_predict(). Please wait...');</span>
0098 <span class="comment">%     set( hwb, 'Name', 'stk_predict' );</span>
0099 <span class="comment">% end</span>
0100 <span class="comment">%</span>
0101 <span class="comment">% block_size = parser.Results.BlockSize;</span>
0102 
0103 display_waitbar = false;
0104 block_size = [];
0105 
0106 <span class="comment">%=== prepare lefthand side of the kriging equation</span>
0107 
0108 [Kii,Pi] = <a href="stk_make_matcov.html" class="code" title="function [K, P] = stk_make_matcov(model, x0, x1)">stk_make_matcov</a>( model,  xi );
0109 
0110 LS = [ [ Kii, Pi                ]; <span class="keyword">...</span>
0111        [ Pi', zeros(size(Pi,2)) ] ];
0112 
0113 [LS_Q,LS_R] = qr( LS ); <span class="comment">% orthogonal-triangular decomposition</span>
0114 
0115 <span class="comment">%=== prepare the output arguments</span>
0116 
0117 zp = struct(<span class="string">'v'</span>,zeros(nt,1));
0118 compute_prediction = ~isempty(zi);
0119 
0120 <span class="comment">% compute the kriging prediction, or just the variances ?</span>
0121 <span class="keyword">if</span> compute_prediction, zp.a = zeros(nt,1); 
0122 <span class="keyword">else</span> zp.a = zeros(nt,0); <span class="keyword">end</span>
0123 
0124 return_weights = ( nargout &gt; 1 ); <span class="comment">% return kriging weights ?</span>
0125 <span class="keyword">if</span> return_weights, lambda = zeros(ni,nt); <span class="keyword">end</span>
0126 
0127 return_lm = ( nargout &gt; 2 ); <span class="comment">% return Lagrange multipliers ?</span>
0128 <span class="keyword">if</span> return_lm, mu = zeros(size(Pi,2),nt); <span class="keyword">end</span>
0129     
0130 <span class="comment">%=== choose nb_blocks &amp; block_size</span>
0131 
0132 <span class="keyword">if</span> isempty( block_size )
0133     MAX_RS_SIZE = 5e6; SIZE_OF_DOUBLE = 8; <span class="comment">% in bytes</span>
0134     block_size = ceil( MAX_RS_SIZE/(ni*SIZE_OF_DOUBLE) );
0135 <span class="keyword">end</span>
0136 
0137 <span class="keyword">if</span> block_size == inf, 
0138     <span class="comment">% biggest possible block size</span>
0139     nb_blocks = 1;
0140 <span class="keyword">else</span>
0141     <span class="comment">% blocks of size approx. block_size</span>
0142     nb_blocks = ceil( nt / block_size );
0143 <span class="keyword">end</span>
0144 
0145 block_size = ceil( nt / nb_blocks );
0146 
0147 
0148 <span class="comment">%=== MAIN LOOP (over blocks)</span>
0149 
0150 linsolve_opt = struct( <span class="string">'UT'</span>, true );
0151 
0152 <span class="keyword">for</span> block_num = 1:nb_blocks
0153     
0154     <span class="comment">% compute the indices for the current block</span>
0155     idx_beg = 1 + block_size*(block_num-1);
0156     idx_end = min( nt, idx_beg+block_size-1 );
0157     idx = idx_beg:idx_end;
0158     
0159     <span class="comment">% extract the block of prediction locations</span>
0160     <span class="keyword">if</span> use_indices, xt_block = xt(idx);
0161     <span class="keyword">else</span> xt_block = struct(<span class="string">'a'</span>,xt.a(idx,:)); <span class="keyword">end</span>
0162     
0163     <span class="comment">% right-hand side of the kriging equation</span>
0164     [Kti,Pt] = <a href="stk_make_matcov.html" class="code" title="function [K, P] = stk_make_matcov(model, x0, x1)">stk_make_matcov</a>( model, xt_block, xi );
0165     RS = [ Kti Pt ]';
0166     
0167     <span class="comment">% solve the upper-triangular system to get the extended</span>
0168     <span class="comment">% kriging weights vector (weights + Lagrange multipliers)</span>
0169     <span class="keyword">if</span> <a href="../misc/config/stk_is_octave_in_use.html" class="code" title="function octave_in_use = stk_is_octave_in_use()">stk_is_octave_in_use</a>(),
0170         lambda_mu = LS_R \ ( LS_Q'*RS ); <span class="comment">% linsolve is missing in Octave</span>
0171     <span class="keyword">else</span>        
0172         lambda_mu = linsolve( LS_R, LS_Q'*RS, linsolve_opt );
0173     <span class="keyword">end</span>
0174     
0175     <span class="keyword">if</span> return_weights, <span class="comment">% extract weights</span>
0176         lambda(:,idx) = lambda_mu(1:ni,:); <span class="keyword">end</span>
0177     
0178     <span class="keyword">if</span> return_lm, <span class="comment">% extracts Lagrange multipliers</span>
0179         mu(:,idx) = lambda_mu((ni+1):<span class="keyword">end</span>,:); <span class="keyword">end</span>
0180     
0181     <span class="keyword">if</span> compute_prediction, <span class="comment">% compute the kriging mean</span>
0182         zp.a(idx) = lambda_mu(1:ni,:)' * zi.a; <span class="keyword">end</span>
0183     
0184     <span class="comment">% compute kriging variances (STATIONARITY ASSUMED)</span>
0185     zp.v(idx) = LS(1,1) - dot(lambda_mu, RS)';
0186     
0187     <span class="keyword">if</span> display_waitbar,
0188         waitbar( idx_end/nt, hwb, sprintf( <span class="keyword">...</span>
0189             <span class="string">'In stk\\_predict(): %d/%d predictions completed'</span>,idx_end,nt) );
0190     <span class="keyword">end</span>
0191 <span class="keyword">end</span>
0192 
0193 <span class="keyword">if</span> display_waitbar, close(hwb); <span class="keyword">end</span>
0194 
0195 <span class="keyword">end</span>
0196 
0197 <span class="comment">%%%%%%%%%%%%%</span>
0198 <span class="comment">%%% tests %%%</span>
0199 <span class="comment">%%%%%%%%%%%%%</span>
0200 
0201 <span class="comment">%!shared model, x0, x_obs, z_obs, x_prd, y_prd1, idx_obs, idx_prd</span>
0202 <span class="comment">%!</span>
0203 <span class="comment">%! n = 20; % 10 observations + 10 predictions</span>
0204 <span class="comment">%! d = 1;  % dimension of the input space</span>
0205 <span class="comment">%!</span>
0206 <span class="comment">%! x0 = stk_sampling_regulargrid(n, d, [0; pi]);</span>
0207 <span class="comment">%!</span>
0208 <span class="comment">%! idx_obs = 1:2:n;</span>
0209 <span class="comment">%! idx_prd = 2:2:n;</span>
0210 <span class="comment">%!</span>
0211 <span class="comment">%! x_obs = struct('a', x0.a(idx_obs));</span>
0212 <span class="comment">%! z_obs = stk_feval(@sin, x_obs);</span>
0213 <span class="comment">%! x_prd = struct('a', x0.a(idx_prd));</span>
0214 <span class="comment">%!</span>
0215 <span class="comment">%! model = stk_model('stk_materncov32_iso');</span>
0216 
0217 <span class="comment">%!error y_prd1 = stk_predict();</span>
0218 <span class="comment">%!error y_prd1 = stk_predict(model);</span>
0219 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs);</span>
0220 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs, z_obs);</span>
0221 <span class="comment">%!test  y_prd1 = stk_predict(model, x_obs, z_obs, x_prd);</span>
0222 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs, z_obs, x_prd, 0);</span>
0223 <span class="comment">%!error y_prd1 = stk_predict(model, x_obs, z_obs, x_prd, 0, 1);</span>
0224 
0225 <span class="comment">%!test</span>
0226 <span class="comment">%!</span>
0227 <span class="comment">%! %% use of Kx_cache</span>
0228 <span class="comment">%! model = stk_model('stk_materncov32_iso');</span>
0229 <span class="comment">%! [model.Kx_cache, model.Px_cache] = stk_make_matcov(model, x0);</span>
0230 <span class="comment">%! y_prd2 = stk_predict(model, idx_obs, z_obs, idx_prd);</span>
0231 <span class="comment">%!</span>
0232 <span class="comment">%! %% check that both methods give the same result</span>
0233 <span class="comment">%! assert(stk_isequal_tolrel(y_prd1, y_prd2));</span></pre></div>
<hr><address>Generated on Mon 01-Oct-2012 15:03:37 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>